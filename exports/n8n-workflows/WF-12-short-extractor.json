{
  "name": "WF-12 Short Extractor",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "wf-12-short-extractor",
        "responseMode": "lastNode",
        "options": {
          "responseData": "firstEntryJson"
        }
      },
      "id": "trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        0,
        0
      ],
      "webhookId": "wf-12-short-extractor"
    },
    {
      "parameters": {
        "language": "javascript",
        "code": "const input = $json;\nconst sourceUrl = input.source_video_url;\nconst isTest = input.mode === 'test';\n\nif (!sourceUrl) {\n  return [{\n    json: {\n      ...input,\n      error: true,\n      error_message: 'source_video_url is required for short extraction',\n      status: 'FAILED'\n    }\n  }];\n}\n\n// Validate URL format\nconst youtubeRegex = /(?:youtube\\.com\\/watch\\?v=|youtu\\.be\\/)([a-zA-Z0-9_-]{11})/;\nconst match = sourceUrl.match(youtubeRegex);\n\nif (!match) {\n  return [{\n    json: {\n      ...input,\n      error: true,\n      error_message: 'Invalid YouTube URL format',\n      status: 'FAILED'\n    }\n  }];\n}\n\nconst videoId = match[1];\n\nreturn [{\n  json: {\n    ...input,\n    source_video_id: videoId,\n    source_video_url: sourceUrl,\n    extraction_config: {\n      target_duration: isTest ? 30 : 60,\n      num_shorts: isTest ? 1 : 3,\n      min_clip_duration: 15,\n      max_clip_duration: 60\n    }\n  }\n}];"
      },
      "id": "validate",
      "name": "Validate Source URL",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        260,
        0
      ]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://www.googleapis.com/youtube/v3/videos?part=snippet,contentDetails&id={{$json.source_video_id}}&key={{$env.YOUTUBE_API_KEY}}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "get_video_info",
      "name": "Get Video Info",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        520,
        0
      ],
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 1000,
      "continueOnFail": true
    },
    {
      "parameters": {
        "language": "javascript",
        "code": "const input = $node['Validate Source URL'].json;\nconst ytResponse = $json;\n\nconst statusCode = ytResponse.statusCode || ytResponse.error?.code;\nif (statusCode && statusCode >= 400) {\n  const errorCode = statusCode === 429\n    ? 'FAILED_YT_RATE_LIMIT'\n    : (statusCode >= 500 ? 'FAILED_YT_UPSTREAM' : 'FAILED_YT_REQUEST');\n\n  return [{\n    json: {\n      ...input,\n      error: true,\n      error_code: errorCode,\n      error_message: ytResponse.error?.message || ytResponse.message || 'YouTube video lookup failed',\n      status: errorCode\n    }\n  }];\n}\n\nif (!ytResponse.items || ytResponse.items.length === 0) {\n  return [{\n    json: {\n      ...input,\n      error: true,\n      error_message: 'Video not found or not accessible',\n      status: 'FAILED_YT_NOT_FOUND'\n    }\n  }];\n}\n\nconst video = ytResponse.items[0];\nconst snippet = video.snippet || {};\nconst contentDetails = video.contentDetails || {};\n\n// Parse duration (ISO 8601 format: PT#H#M#S)\nconst durationStr = contentDetails.duration || 'PT0S';\nconst durationMatch = durationStr.match(/PT(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)S)?/);\nconst hours = parseInt(durationMatch?.[1] || 0);\nconst minutes = parseInt(durationMatch?.[2] || 0);\nconst seconds = parseInt(durationMatch?.[3] || 0);\nconst totalSeconds = hours * 3600 + minutes * 60 + seconds;\n\nreturn [{\n  json: {\n    ...input,\n    source_video: {\n      id: input.source_video_id,\n      title: snippet.title,\n      description: snippet.description,\n      channel: snippet.channelTitle,\n      duration_seconds: totalSeconds,\n      tags: snippet.tags || [],\n      category_id: snippet.categoryId\n    }\n  }\n}];"
      },
      "id": "parse_video_info",
      "name": "Parse Video Info",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        780,
        0
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{$env.OPENAI_API_KEY}}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"gpt-4o-mini\",\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"You are a video content analyst specializing in identifying viral-worthy moments for YouTube Shorts. Analyze video metadata and suggest optimal timestamps for short clips.\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"Analyze this video and suggest {{$json.extraction_config.num_shorts}} viral-worthy segments for YouTube Shorts (max {{$json.extraction_config.max_clip_duration}} seconds each):\\n\\nTitle: {{$json.source_video.title}}\\nDuration: {{$json.source_video.duration_seconds}} seconds\\nDescription: {{$json.source_video.description.substring(0, 500)}}\\nTags: {{($json.source_video.tags || []).slice(0, 10).join(', ')}}\\n\\nRespond in JSON format:\\n{\\n  \\\"segments\\\": [\\n    {\\n      \\\"start_time\\\": number (seconds),\\n      \\\"end_time\\\": number (seconds),\\n      \\\"duration\\\": number (seconds),\\n      \\\"hook\\\": \\\"attention-grabbing title for this segment\\\",\\n      \\\"viral_score\\\": 1-100,\\n      \\\"reasoning\\\": \\\"why this segment would work as a Short\\\"\\n    }\\n  ]\\n}\\n\\nFocus on: hooks, surprising moments, valuable tips, emotional peaks, or cliffhangers.\"\n    }\n  ],\n  \"max_tokens\": 1000,\n  \"temperature\": 0.7\n}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "analyze_segments",
      "name": "AI Segment Analysis",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1040,
        0
      ],
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 2000,
      "continueOnFail": true
    },
    {
      "parameters": {
        "language": "javascript",
        "code": "const input = $node['Parse Video Info'].json;\nconst aiResponse = $json;\nconst now = new Date().toISOString();\n\nif (input.error) {\n  return [{ json: input }];\n}\n\nconst statusCode = aiResponse.statusCode || aiResponse.error?.code;\nif (statusCode && statusCode >= 400) {\n  const errorCode = statusCode === 429\n    ? 'FAILED_OPENAI_RATE_LIMIT'\n    : (statusCode >= 500 ? 'FAILED_OPENAI_UPSTREAM' : 'FAILED_OPENAI_REQUEST');\n\n  return [{\n    json: {\n      run_id: input.run_id,\n      mode: input.mode,\n      error: true,\n      error_code: errorCode,\n      error_message: aiResponse.error?.message || aiResponse.message || 'Shorts analysis failed',\n      status: errorCode\n    }\n  }];\n}\n\nlet segments = [];\n\ntry {\n  if (aiResponse.choices && aiResponse.choices[0]?.message?.content) {\n    const content = aiResponse.choices[0].message.content;\n    const jsonMatch = content.match(/\\[[\\s\\S]*\\]/);\n    if (jsonMatch) {\n      segments = JSON.parse(jsonMatch[0]);\n    }\n  }\n} catch (e) {\n  // fallback to empty\n}\n\nconst outputSegments = segments.map((segment, index) => ({\n  ...segment,\n  index: index + 1,\n  source_video_id: input.source_video?.id,\n  source_title: input.source_video?.title\n}));\n\nreturn [{\n  json: {\n    ...input,\n    short_segments: outputSegments,\n    analyzed_at: now,\n    status: 'SHORTS_ANALYZED'\n  }\n}];"
      },
      "id": "process_segments",
      "name": "Process Segments",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1300,
        0
      ]
    },
    {
      "parameters": {
        "operation": "insert",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "mode": "list",
          "value": "yt_studio_shorts_extraction"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "run_id": "={{ $json.run_id }}",
            "source_video_id": "={{ $json.source_video.id }}",
            "source_video_title": "={{ $json.source_video.title }}",
            "segments": "={{ JSON.stringify($json.segments) }}",
            "status": "={{ $json.status }}"
          }
        },
        "options": {}
      },
      "id": "save_extraction",
      "name": "Save Extraction Results",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        1560,
        0
      ],
      "credentials": {
        "postgres": {
          "id": "postgres_yt_studio",
          "name": "PostgreSQL YT Studio"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "language": "javascript",
        "code": "const input = $node['Process Segments'].json;\nconst now = new Date().toISOString();\n\n// Build response with extraction instructions\nconst extractionJobs = input.segments.map(segment => ({\n  segment_id: segment.segment_id,\n  source_url: `https://youtube.com/watch?v=${input.source_video.id}`,\n  start_time: segment.start_time,\n  end_time: segment.end_time,\n  duration: segment.duration,\n  suggested_title: segment.hook,\n  viral_score: segment.viral_score,\n  \n  // These would be used by the orchestrator to create individual short videos\n  create_request: {\n    mode: input.mode,\n    video_type: 'short',\n    custom_topic: segment.hook,\n    source_segment: {\n      video_id: input.source_video.id,\n      start: segment.start_time,\n      end: segment.end_time\n    }\n  }\n}));\n\nreturn [{\n  json: {\n    run_id: input.run_id,\n    mode: input.mode,\n    source_video: {\n      id: input.source_video.id,\n      title: input.source_video.title,\n      duration: input.source_video.duration_seconds\n    },\n    extraction_jobs: extractionJobs,\n    total_shorts_to_create: extractionJobs.length,\n    completed_at: now,\n    status: extractionJobs.length > 0 ? 'EXTRACTION_READY' : 'NO_EXTRACTION_POSSIBLE'\n  }\n}];"
      },
      "id": "build_response",
      "name": "Build Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1820,
        0
      ]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Validate Source URL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Source URL": {
      "main": [
        [
          {
            "node": "Get Video Info",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Video Info": {
      "main": [
        [
          {
            "node": "Parse Video Info",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Video Info": {
      "main": [
        [
          {
            "node": "AI Segment Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Segment Analysis": {
      "main": [
        [
          {
            "node": "Process Segments",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Segments": {
      "main": [
        [
          {
            "node": "Save Extraction Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Extraction Results": {
      "main": [
        [
          {
            "node": "Build Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "yt-studio-wf-12-v1",
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "id": "wf-12"
}
