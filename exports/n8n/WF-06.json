{
  "name": "WF-06 Scene Asset Build",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "wf-06",
        "responseMode": "lastNode",
        "options": {
          "responseData": "firstEntryJson"
        }
      },
      "id": "1",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [0, 0],
      "webhookId": "wf-06-trigger"
    },
    {
      "parameters": {
        "language": "javascript",
        "code": "const input = $json;\nconst contract = input;\n\n// Get API keys from env or resolved_config\nconst pexelsApiKey = $env.PEXELS_API_KEY || contract.resolved_config?.pexels?.api_key;\nconst openaiApiKey = $env.OPENAI_API_KEY || contract.resolved_config?.openai?.api_key;\n\nif (!pexelsApiKey && !openaiApiKey) {\n  throw new Error('No asset generation API keys configured (PEXELS_API_KEY or OPENAI_API_KEY required)');\n}\n\n// Get scene plan from manifest\nconst scenePlan = contract.manifest?.assets?.scene_plan || [];\nconst approvedScript = contract.manifest?.script?.approved || '';\nconst topic = contract.manifest?.topic || {};\n\n// Extract scenes from script if scene_plan is empty\nlet scenes = scenePlan;\nif (scenes.length === 0) {\n  const sceneRegex = /\\[SCENE\\s*(\\d+):\\s*([^\\]]+)\\]/gi;\n  let match;\n  while ((match = sceneRegex.exec(approvedScript)) !== null) {\n    scenes.push({\n      scene: parseInt(match[1]),\n      description: match[2].trim(),\n      duration_sec: 25.0\n    });\n  }\n}\n\n// If still no scenes, create default scenes\nif (scenes.length === 0) {\n  scenes = [\n    { scene: 1, description: topic.title || 'Introduction', duration_sec: 30.0 },\n    { scene: 2, description: topic.summary || 'Main content', duration_sec: 30.0 },\n    { scene: 3, description: 'Conclusion', duration_sec: 30.0 }\n  ];\n}\n\n// Prepare scene requests with keywords for search\nconst sceneRequests = scenes.map((scene, index) => {\n  // Extract keywords from scene description for search\n  const searchKeywords = scene.description\n    .toLowerCase()\n    .replace(/[^a-zA-Z0-9\\s]/g, '')\n    .split(' ')\n    .filter(word => word.length > 3)\n    .slice(0, 3)\n    .join(' ');\n  \n  return {\n    scene_index: index,\n    scene_number: scene.scene,\n    scene_description: scene.description,\n    duration_sec: scene.duration_sec,\n    search_query: searchKeywords || topic.title || 'education'\n  };\n});\n\nreturn [\n  {\n    json: {\n      ...contract,\n      pexels_api_key: pexelsApiKey,\n      openai_api_key: openaiApiKey,\n      scene_requests: sceneRequests,\n      scene_plan: scenes\n    }\n  }\n];"
      },
      "id": "2",
      "name": "Prepare Asset Requests",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [260, 0]
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "={{$json.scene_requests}}",
        "options": {}
      },
      "id": "3",
      "name": "Split Scenes",
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [520, 0]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://api.pexels.com/videos/search?query={{encodeURIComponent($json.search_query)}}&per_page=5&orientation=landscape&size=large",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{$node['Prepare Asset Requests'].json.pexels_api_key}}"
            }
          ]
        },
        "options": {
          "timeout": 30000
        }
      },
      "id": "4",
      "name": "Search Pexels Video",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [780, 0],
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 1000,
      "continueOnFail": true
    },
    {
      "parameters": {
        "language": "javascript",
        "code": "const sceneData = $node['Split Scenes'].json;\nconst videoResponse = $json;\n\n// Check if we found a suitable video\nlet foundVideo = null;\nif (videoResponse.videos && Array.isArray(videoResponse.videos) && videoResponse.videos.length > 0) {\n  // Find a video with minimum 5 seconds duration and 1920x1080 resolution\n  for (const video of videoResponse.videos) {\n    if (video.duration >= 5) {\n      // Get the best quality video file\n      const videoFiles = video.video_files || [];\n      const hdFile = videoFiles.find(f => f.width >= 1920 && f.height >= 1080) || videoFiles[0];\n      \n      if (hdFile) {\n        foundVideo = {\n          id: video.id,\n          url: hdFile.link,\n          duration: video.duration,\n          width: hdFile.width,\n          height: hdFile.height,\n          photographer: video.user?.name || 'Unknown'\n        };\n        break;\n      }\n    }\n  }\n}\n\nreturn [\n  {\n    json: {\n      ...sceneData,\n      pexels_video_result: foundVideo,\n      need_photo_fallback: !foundVideo\n    }\n  }\n];"
      },
      "id": "5",
      "name": "Check Video Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1040, 0]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.need_photo_fallback}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "id": "6",
      "name": "Need Photo Fallback?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1300, 0]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://api.pexels.com/v1/search?query={{encodeURIComponent($json.search_query)}}&per_page=5&orientation=landscape",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{$node['Prepare Asset Requests'].json.pexels_api_key}}"
            }
          ]
        },
        "options": {
          "timeout": 30000
        }
      },
      "id": "7",
      "name": "Search Pexels Photo",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1560, -100],
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 1000,
      "continueOnFail": true
    },
    {
      "parameters": {
        "language": "javascript",
        "code": "const sceneData = $node['Check Video Result'].json;\nconst photoResponse = $json;\n\n// Check if we found a suitable photo\nlet foundPhoto = null;\nif (photoResponse.photos && Array.isArray(photoResponse.photos) && photoResponse.photos.length > 0) {\n  // Find a photo with minimum 1920x1080 resolution\n  for (const photo of photoResponse.photos) {\n    if (photo.width >= 1920 && photo.height >= 1080) {\n      foundPhoto = {\n        id: photo.id,\n        url: photo.src?.original || photo.src?.large2x || photo.src?.large,\n        width: photo.width,\n        height: photo.height,\n        photographer: photo.photographer || 'Unknown'\n      };\n      break;\n    }\n  }\n  // Fallback to first photo if no HD found\n  if (!foundPhoto && photoResponse.photos[0]) {\n    const photo = photoResponse.photos[0];\n    foundPhoto = {\n      id: photo.id,\n      url: photo.src?.original || photo.src?.large2x || photo.src?.large,\n      width: photo.width,\n      height: photo.height,\n      photographer: photo.photographer || 'Unknown'\n    };\n  }\n}\n\nreturn [\n  {\n    json: {\n      ...sceneData,\n      pexels_photo_result: foundPhoto,\n      need_dalle_fallback: !foundPhoto\n    }\n  }\n];"
      },
      "id": "8",
      "name": "Check Photo Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1820, -100]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.need_dalle_fallback}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "id": "9",
      "name": "Need DALL-E Fallback?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2080, -100]
    },
    {
      "parameters": {
        "language": "javascript",
        "code": "const sceneData = $json;\n\n// Islamic-appropriate prompt for DALL-E\nconst basePrompt = sceneData.scene_description;\nconst dallePrompt = `Digital illustration for educational video: ${basePrompt}. Style: Clean, modern infographic style with geometric patterns. Important: No human faces, no human figures, no living creatures. Use abstract shapes, nature elements (mountains, water, sky, plants), geometric Islamic patterns, scientific diagrams, and symbolic representations. Color palette: Calming blues, greens, and earth tones. High quality, professional educational content.`;\n\nreturn [\n  {\n    json: {\n      ...sceneData,\n      dalle_prompt: dallePrompt\n    }\n  }\n];"
      },
      "id": "10",
      "name": "Prepare DALL-E Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2340, -200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/images/generations",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{$node['Prepare Asset Requests'].json.openai_api_key}}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"dall-e-3\",\n  \"prompt\": {{JSON.stringify($json.dalle_prompt)}},\n  \"n\": 1,\n  \"size\": \"1792x1024\",\n  \"quality\": \"standard\",\n  \"response_format\": \"url\"\n}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "11",
      "name": "Call DALL-E API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [2600, -200],
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 5000,
      "continueOnFail": true
    },
    {
      "parameters": {
        "language": "javascript",
        "code": "const sceneData = $node['Prepare DALL-E Prompt'].json;\nconst dalleResponse = $json;\n\nlet dalleResult = null;\nif (dalleResponse.data && dalleResponse.data[0]) {\n  dalleResult = {\n    url: dalleResponse.data[0].url,\n    revised_prompt: dalleResponse.data[0].revised_prompt\n  };\n}\n\nreturn [\n  {\n    json: {\n      scene_index: sceneData.scene_index,\n      scene_number: sceneData.scene_number,\n      scene_description: sceneData.scene_description,\n      duration_sec: sceneData.duration_sec,\n      asset_type: 'image',\n      asset_source: 'dalle_generated',\n      asset_url: dalleResult?.url || null,\n      asset_license: 'DALL-E',\n      pexels_id: null,\n      photographer: null,\n      resolution: '1792x1024',\n      generation_error: dalleResult ? null : 'DALL-E generation failed'\n    }\n  }\n];"
      },
      "id": "12",
      "name": "Format DALL-E Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2860, -200]
    },
    {
      "parameters": {
        "language": "javascript",
        "code": "const sceneData = $json;\nconst photoResult = sceneData.pexels_photo_result;\n\nreturn [\n  {\n    json: {\n      scene_index: sceneData.scene_index,\n      scene_number: sceneData.scene_number,\n      scene_description: sceneData.scene_description,\n      duration_sec: sceneData.duration_sec,\n      asset_type: 'image',\n      asset_source: 'pexels_photo',\n      asset_url: photoResult.url,\n      asset_license: 'Pexels',\n      pexels_id: String(photoResult.id),\n      photographer: photoResult.photographer,\n      resolution: `${photoResult.width}x${photoResult.height}`,\n      generation_error: null\n    }\n  }\n];"
      },
      "id": "13",
      "name": "Format Photo Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2340, 0]
    },
    {
      "parameters": {
        "language": "javascript",
        "code": "const sceneData = $json;\nconst videoResult = sceneData.pexels_video_result;\n\nreturn [\n  {\n    json: {\n      scene_index: sceneData.scene_index,\n      scene_number: sceneData.scene_number,\n      scene_description: sceneData.scene_description,\n      duration_sec: sceneData.duration_sec,\n      asset_type: 'video',\n      asset_source: 'pexels_video',\n      asset_url: videoResult.url,\n      asset_license: 'Pexels',\n      pexels_id: String(videoResult.id),\n      photographer: videoResult.photographer,\n      resolution: `${videoResult.width}x${videoResult.height}`,\n      video_duration: videoResult.duration,\n      generation_error: null\n    }\n  }\n];"
      },
      "id": "14",
      "name": "Format Video Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1560, 100]
    },
    {
      "parameters": {
        "mode": "combine",
        "mergeByFields": {
          "values": []
        },
        "options": {}
      },
      "id": "15",
      "name": "Merge All Results",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [3120, 0]
    },
    {
      "parameters": {
        "language": "javascript",
        "code": "const now = new Date().toISOString();\nconst items = $input.all();\nconst prepareNode = $node['Prepare Asset Requests'].json;\n\n// Remove sensitive data\nconst contract = { ...prepareNode };\ndelete contract.pexels_api_key;\ndelete contract.openai_api_key;\ndelete contract.scene_requests;\n\ntry {\n  contract.manifest.audit.change_log.push({\n    at: now,\n    by: 'wf-06',\n    change: `step=wf-06 status=STARTED run_id=${contract.run_id} mode=${contract.mode}`\n  });\n\n  const storageBaseUrl = contract.resolved_config?.storage?.base_url || 'https://storage.example.com';\n  const generatedAssets = [];\n  const scenePlan = contract.scene_plan || [];\n  \n  // Process each asset result\n  for (const item of items) {\n    const data = item.json;\n    const assetId = `asset_${contract.run_id}_${String(data.scene_number).padStart(3, '0')}`;\n    const extension = data.asset_type === 'video' ? 'mp4' : 'png';\n    \n    const asset = {\n      asset_id: assetId,\n      type: data.asset_type,\n      source: data.asset_source,\n      source_url: data.asset_url,\n      local_path: `/mnt/assets/${contract.run_id}/scene_${data.scene_number}.${extension}`,\n      checksum_sha256: '',\n      duration_sec: data.duration_sec,\n      resolution: data.resolution,\n      license: data.asset_license,\n      metadata: {\n        pexels_id: data.pexels_id,\n        photographer: data.photographer,\n        scene_number: data.scene_number,\n        scene_description: data.scene_description,\n        video_duration: data.video_duration || null,\n        generation_error: data.generation_error\n      }\n    };\n    \n    generatedAssets.push(asset);\n  }\n  \n  // Sort by scene number\n  generatedAssets.sort((a, b) => a.metadata.scene_number - b.metadata.scene_number);\n  \n  // Update contract\n  contract.scene_assets = generatedAssets;\n  contract.manifest.assets.items = generatedAssets;\n  contract.manifest.assets.scene_plan = scenePlan;\n  contract.manifest.timestamps.phase = 'assets_ready';\n  contract.manifest.timestamps.updated_at = now;\n  contract.manifest.audit.updated_by = 'wf-06';\n  \n  // Clean up temporary fields\n  delete contract.scene_plan;\n\n  // Count by source\n  const sourceCount = {\n    pexels_video: generatedAssets.filter(a => a.source === 'pexels_video').length,\n    pexels_photo: generatedAssets.filter(a => a.source === 'pexels_photo').length,\n    dalle_generated: generatedAssets.filter(a => a.source === 'dalle_generated').length,\n    errors: generatedAssets.filter(a => a.metadata.generation_error).length\n  };\n  \n  contract.manifest.audit.change_log.push({\n    at: now,\n    by: 'wf-06',\n    change: `step=wf-06 status=COMPLETED run_id=${contract.run_id} mode=${contract.mode} videos=${sourceCount.pexels_video} photos=${sourceCount.pexels_photo} dalle=${sourceCount.dalle_generated} errors=${sourceCount.errors}`\n  });\n\n  return [\n    {\n      json: {\n        run_id: contract.run_id,\n        mode: contract.mode,\n        scene_assets: contract.scene_assets,\n        voiceover_url_signed: contract.voiceover_url_signed,\n        render_id: contract.render_id,\n        youtube_video_id: contract.youtube_video_id,\n        manifest: contract.manifest,\n        resolved_config: contract.resolved_config,\n        environment: contract.environment,\n        scope: contract.scope,\n        channel_id: contract.channel_id,\n        runtime_overrides: contract.runtime_overrides,\n        worker: 'WF-06',\n        status: 'COMPLETED',\n        output_summary: `generated ${generatedAssets.length} assets (${sourceCount.pexels_video} videos, ${sourceCount.pexels_photo} photos, ${sourceCount.dalle_generated} DALL-E)`\n      }\n    }\n  ];\n} catch (error) {\n  const message = error && error.message ? error.message : 'unknown_error';\n  \n  if (contract.manifest && contract.manifest.timestamps) {\n    contract.manifest.timestamps.phase = 'failed_wf_06';\n    contract.manifest.timestamps.updated_at = now;\n    contract.manifest.audit.change_log.push({\n      at: now,\n      by: 'wf-06',\n      change: `step=wf-06 status=FAILED error_code=FAILED_WF_06 error_message=${message} run_id=${contract.run_id} mode=${contract.mode}`\n    });\n  }\n  \n  return [\n    {\n      json: {\n        run_id: contract.run_id || null,\n        mode: contract.mode || null,\n        scene_assets: contract.scene_assets || [],\n        voiceover_url_signed: contract.voiceover_url_signed || null,\n        render_id: contract.render_id || null,\n        youtube_video_id: contract.youtube_video_id || null,\n        manifest: contract.manifest || null,\n        resolved_config: contract.resolved_config || null,\n        worker: 'WF-06',\n        status: 'FAILED_WF_06',\n        output_summary: `error=${message}`\n      }\n    }\n  ];\n}"
      },
      "id": "16",
      "name": "Process Assets Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3380, 0]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [{"node": "Prepare Asset Requests", "type": "main", "index": 0}]
      ]
    },
    "Prepare Asset Requests": {
      "main": [
        [{"node": "Split Scenes", "type": "main", "index": 0}]
      ]
    },
    "Split Scenes": {
      "main": [
        [{"node": "Search Pexels Video", "type": "main", "index": 0}]
      ]
    },
    "Search Pexels Video": {
      "main": [
        [{"node": "Check Video Result", "type": "main", "index": 0}]
      ]
    },
    "Check Video Result": {
      "main": [
        [{"node": "Need Photo Fallback?", "type": "main", "index": 0}]
      ]
    },
    "Need Photo Fallback?": {
      "main": [
        [{"node": "Search Pexels Photo", "type": "main", "index": 0}],
        [{"node": "Format Video Result", "type": "main", "index": 0}]
      ]
    },
    "Search Pexels Photo": {
      "main": [
        [{"node": "Check Photo Result", "type": "main", "index": 0}]
      ]
    },
    "Check Photo Result": {
      "main": [
        [{"node": "Need DALL-E Fallback?", "type": "main", "index": 0}]
      ]
    },
    "Need DALL-E Fallback?": {
      "main": [
        [{"node": "Prepare DALL-E Prompt", "type": "main", "index": 0}],
        [{"node": "Format Photo Result", "type": "main", "index": 0}]
      ]
    },
    "Prepare DALL-E Prompt": {
      "main": [
        [{"node": "Call DALL-E API", "type": "main", "index": 0}]
      ]
    },
    "Call DALL-E API": {
      "main": [
        [{"node": "Format DALL-E Result", "type": "main", "index": 0}]
      ]
    },
    "Format Video Result": {
      "main": [
        [{"node": "Merge All Results", "type": "main", "index": 0}]
      ]
    },
    "Format Photo Result": {
      "main": [
        [{"node": "Merge All Results", "type": "main", "index": 0}]
      ]
    },
    "Format DALL-E Result": {
      "main": [
        [{"node": "Merge All Results", "type": "main", "index": 0}]
      ]
    },
    "Merge All Results": {
      "main": [
        [{"node": "Process Assets Result", "type": "main", "index": 0}]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "00000000-0000-0000-0000-000000000006",
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "id": "6"
}
